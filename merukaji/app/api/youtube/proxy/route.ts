// app/api/youtube/proxy/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/authOptions';
import { logger } from '@/lib/logger';

// Define types for YouTube caption data
interface CaptionTrack {
    baseUrl: string;
    name: {
        simpleText?: string;
    };
    languageCode: string;
    kind?: string;
    isAutoGenerated?: boolean;
}

interface YouTubeCaptionsResponse {
    captions?: {
        playerCaptionsTracklistRenderer?: {
            captionTracks?: CaptionTrack[];
        };
    };
    videoDetails?: {
        title?: string;
        author?: string;
        lengthSeconds?: string;
    };
    microformat?: {
        playerMicroformatRenderer?: {
            publishDate?: string;
        };
    };
}

export async function POST(req: NextRequest) {
    try {
        // Ensure user is authenticated
        const session = await getServerSession(authOptions);
        if (!session?.user) {
            return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
        }

        const { videoId } = await req.json();

        if (!videoId) {
            return NextResponse.json({ error: 'Video ID is required' }, { status: 400 });
        }

        // Fetch video page with appropriate headers
        const videoUrl = `https://www.youtube.com/watch?v=${videoId}`;
        const response = await fetch(videoUrl, {
            headers: {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
                'Accept-Language': 'en-US,en;q=0.9',
                'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
            },
        });

        if (!response.ok) {
            throw new Error(`Failed to fetch video page: ${response.status}`);
        }

        const html = await response.text();

        // Extract ytInitialPlayerResponse
        const ytInitialPlayerResponseMatch = html.match(/ytInitialPlayerResponse\s*=\s*({.+?});/);
        if (!ytInitialPlayerResponseMatch) {
            throw new Error('Could not find player response');
        }

        const playerResponse = JSON.parse(ytInitialPlayerResponseMatch[1]) as YouTubeCaptionsResponse;

        // Check for captions in both standard and auto-generated formats
        let captionTracks: CaptionTrack[] | undefined =
            playerResponse?.captions?.playerCaptionsTracklistRenderer?.captionTracks;

        // If no standard captions, check for auto-generated captions
        if (!captionTracks || captionTracks.length === 0) {
            // Extract auto-generated captions data
            const autoCapMatch = html.match(/"captions":{"playerCaptionsRenderer":{"baseUrl":"([^"]+)"/);
            if (autoCapMatch && autoCapMatch[1]) {
                // Create a caption track from auto-generated captions
                captionTracks = [{
                    baseUrl: autoCapMatch[1].replace(/\\u0026/g, '&'),
                    name: { simpleText: 'Auto-generated' },
                    languageCode: 'en',
                    kind: 'asr', // automatic speech recognition
                    isAutoGenerated: true
                }];
            }
        }

        if (!captionTracks || captionTracks.length === 0) {
            throw new Error('No captions available for this video');
        }

        // Prefer manual captions over auto-generated ones
        const manualCaptions = captionTracks.find(track => track.kind !== 'asr');
        const captionTrack = manualCaptions || captionTracks[0];

        // Log caption source for debugging
        logger.info('Using caption track:', {
            type: captionTrack.kind === 'asr' ? 'auto-generated' : 'manual',
            language: captionTrack.languageCode,
            name: captionTrack.name.simpleText
        });

        // Fetch the transcript
        const captionUrl = captionTrack.baseUrl;
        const transcriptResponse = await fetch(captionUrl);

        if (!transcriptResponse.ok) {
            throw new Error('Failed to fetch transcript');
        }

        const transcriptXml = await transcriptResponse.text();

        // Add language information to the response
        const languageInfo = {
            code: captionTrack.languageCode,
            isAutoGenerated: captionTrack.kind === 'asr',
            name: captionTrack.name.simpleText
        };

        // Return both the player response and transcript
        return NextResponse.json({
            success: true,
            playerResponse,
            transcript: transcriptXml,
            language: languageInfo
        });

    } catch (error) {
        logger.error('YouTube proxy error:', {
            error: error instanceof Error ? error.message : String(error)
        });

        return NextResponse.json({
            error: error instanceof Error ? error.message : 'Failed to fetch video data'
        }, { status: 500 });
    }
}